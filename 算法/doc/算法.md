# 算法

神魔是数据:数据之间相互存在的一种或多种特定的关系的元素的集合

逻辑结构:

​	1 集合结构 

​	2 线性结构

​	3 树形结构

​	4 图形结构

逻辑结构:

​	1 顺序存储结构

​	2 链式存储结构



线性表  **List**

a1-->a2 --->a3 -->a4 ...... -->an-1 ---> an

a1是 a2 的前驱 ,a2是a1 的后继     a1 没有前驱  an 没有后继

```
ArrayList
	
	扩容
	Object[] newArray = new Object[s+(s<MIN_CAPACITY_INCREMENT/2)? MIN_CAPACITY_INCREMENT : s >>1]
	
	容量为12的话 
	s = 4  扩容4+12 =16 
	s = 14 扩容 14 +14/2= 21
	
	
	
```

 

```
LinkedList  
 链表 
 public class LinkedList<E>
    extends AbstractSequentialList<E>
    
    transient Node<E> first; 头指针
    transient Node<E> last; 尾指针

```

​	

**线性结构** ---> 最常用的数据结构  元素之间存在一对一的线性关系  线性结构  又分为 顺序结构 和链式结构  

顺序结构存储的称为顺序表顺序表中存储元素是连续的

链式存储的线性表 称为链表  链表中的存储元素不一定是连续的  元素节点中存放的 是   元素值 和相邻的地址信息 

线性结构常见的有 数组 队列 链表和栈 

**非线性结构** : 包括 二维数组 多维数组 广义表 树结构 图结构 

**稀疏数组** : 当一个数组大部分元素为0 或者同一个值的数组时, 可以用稀疏数组保存该数组 

 row 行  col 列 value 值  

队列 :  有序列表 可以用数组	或链表实现

遵循先入先出的原则 先存入队列的数据 先取出  后存入的数据 后取出



**fifo**是指first in，first out。。。是队列程序

**lifo**是指last in，first out。。。。是堆栈程序

队列是一个有序列表 可以用数组或链表来实现  遵循先入先出的原则 先存入的 队列的数据 要先取出  后存入的数据要后取出 

bug1  问题并优化

 1 目前数据使用一次就不能复用  没有达到服用的效果

2 将这个数组使用算法  ,该近成 一个环形数组   取模 %



链表 LinkedList  以 节点的方式来存储

每个节点包含date 域 ,next 域  指向下一个节点 

如图: 发现链表的各个节点  不一定是连续存放

链表 分带头节点的链表 和没有头节点的链表  根据实际的需求来确定

头节点  1  不存放具体的数据

2    表示单链表头 



最后一个数据  next  为null 

需要按照编号的顺序来添加

​	1 首先找到添加的节点的位置 ,是通过辅助变量 (指针) 通过遍历来搞定

​	2 新的节点.next = temp.next 

​	3 将temp .next = 新的节点 



单向链表 缺点 

1 查找方向 只能是一个方向 而双向链表可以向前 或者 向后查找

2 查找但钱链表不能自我删除 需要辅助节点 而双向链表 则可以实现自我删除 



栈  stack 

栈 是一个陷入后出的有序列表

栈 是限制线性表中元素的插入和删除 只能在先线性表中的同一端进行的一种特殊线性表 允许插入和删除 的一段  为 变换的一段 称为top  栈顶  另一端 为栈底 bottom 

根据栈的定义可知 最先放入栈中元素在栈底  最后放入的元素在栈 顶 删除元素 则 最后放入的最先删除   最先 放入的元素最后 删除 



前缀表达式 - * + 3456  从右往左

中缀表达式(3+4)*5 -6

后缀表达式 (又叫做 逆波兰计算器)3  4 + 5 * 6 - 从 左往右

```
前缀表达式 的计算机求值 
从右至左 扫描表达式 
	遇到数字时  将其压栈  遇到运算发 将其栈顶的两个元素弹栈
    比如 (3+4)*5 -6  前缀表达式就是  - * + 3456 
    1 从右至左 扫描 ,将  6543 压入栈  
    2 遇到+ 运算符 弹出3 和4 3 为  栈顶 元素   4 为次顶元素  计算出3 + 4 的值 得 7  再 将 7 入栈  
    3 接下来是*运算符  弹栈 7 和5  计算出7*5 = 35 将 35 入栈
    4最后是- 运算符  弹栈 35 6 计算35 -6 的值  即 29   先弹出的数  减去 后弹出的数 
    
```



 java 中 matches  方法 

| \d   | 任意一个数字，0~9 中的任意一个                   |
| ---- | ----------------------------------- |
| \w   | 任意一个字母或数字或下划线，也就是 AZ,az,0~9,_ 中任意一个 |
| \s   | 包括空格、制表符、换页符等空白字符的其中任意一个            |
| .    | 小数点可以匹配除了换行符（\n）以外的任意一个字符           |





**递归**

递归就是方法自己调用自己,每次调用时传入不同的变量

```
递归需要遵守的原则:
	1) 执行一个方法是 ,就创建一个新的受保护的独立空间(栈空间)
	2) 方法的局部变量是独立的,不会相互影响
	3) 递归必须向退出递归的条件逼近 ,否则就会无限递归了
	4) 当一个方法执行完毕 ,或者遇到return,就会返回,遵守谁调用,就将结果返回给谁,同时当方法执行完毕或者返回时 ,该方法也就执行完毕
	5) 如果方法中使用的是引用类型变量(比如数组) ,就会共享该引用类型的数据
```



**排序**   将一组数据  按照指定的顺序进行排列的过程

内部排序  将需要处理的所有数据都加载到内部存储器中进行排序

外部排序 数据量过大 无法全部加载到内存中 需要借助外部存储进行排序

度量一个程序执行时间的两种方法

1) 事后统计的方法  存在两个问题 一是要对设计的算法的运行性能进行评测 ,需要实际运行该程序,二是所得时间的 统计量依赖计算机的硬件 软件等环境因素 这种方式,要在同一台计算机的相同状态下 运行,才能比较哪个算法速度更快

2) 事前估算的方法   通过分析某个算法的时间复杂度来判断哪个算法更优



时间频度 : 一个算法中的语句执行次数称为语句频度或时间频度

**插入排序**

插入式排序属于内部排序法,是对于欲排序的元素以插入的方式寻找该元素的适当位置,以达到排序的目的

当需要插入的数是较小的数时 ,后移的次数明显增多,对效率有影响



归并排序  是利用归并的思想实现的排序方法,  采用经典的分治策略(将问题分成一些小的问题然后递归求解,治的阶段 将得到的各答案修补在一起 ) 

斐波那契查找算法 

（1）如果与给定关键字相同，则查找成功，返回在表中的位置；

（2）如果给定关键字大，向右查找并减小2个斐波那契区间；

（3）如果给定关键字小，向左查找并减小1个斐波那契区间；

（4）重复过程，直到找到关键字（成功）或区间为空集（失败）。



存储数据有哪几种方式:

1 数组 2 链式存储 3 树存储方式

优缺点 

  1) 树  优点 通过下标方式访问元素 速度快, 对于有序数组 ,还可以使用二分查找提高检索速度 

 缺点 : 如果检索具体某个值 或者插入值 (按一定顺序) 会整体移动 效率较低 

2) 优点 在一定程度上对数组存储播放时有优化(比如 插入一个数值节点  只需要将插入节点  链接到 链表 中即可 删除效率也很好)

缺点 在进行检索式 效率比较低   比如检索某个值 需要从头节点 开始遍历 

3) 树存储方式的分析

 能提高数据存储 读取的效率  比如二叉树排序树  既可以保证数据的检索速度,同时也可以保证数据的插入删除 修改的速度



二叉树 遍历说明

前序 遍历 先输出父节点 再遍历左子树   和 右子树 

中序遍历 先遍历左子树 在输出父节点 再遍历右字树

后序遍历 : 先遍历左子树 再遍历右子树 最后输出父节点



根据父节点的输出顺序 来区分 



大顶堆 升序   小顶堆降序



二叉树的 高度深度 层数



![](../../img/algorithm/tree.png)

图的遍历 : 即对 节点的访问 一个图有多个节点 如何遍历这些节点  需要特定的策略  一般有两种访问策略

1) 深度优先遍历 DFS  2 ) 广度有限遍历 

Depth First Search   深度有限搜索  从访问节点出发,初始访问节点可能有多个邻接节点 深度优先便利的策略就是首先访问第一个邻接节点 然后再以这个被访问的邻接节点作为初始节点 访问它的第一个邻接节点 可以这样理解 每次都在访问当前节点后首先访问当前节点的第一个邻接节点

这样的访问策略 是优先往纵向挖掘深入 而不是对一个节点的所有临节点 进行横向访问

深度优先搜索是一个递归的过程